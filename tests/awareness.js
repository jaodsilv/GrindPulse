/**
 * Awareness Indicator JavaScript Functions (Extracted for Testing)
 * These functions are normally embedded in the generated HTML file
 */

/**
 * SYNCHRONIZATION REQUIREMENT:
 * These functions mirror the JavaScript code generated by js_awareness_generator.py.
 * When modifying getTierName(), getTierDifficultyMultiplier(), getCommitmentFactor(),
 * getSolvedFactor(), getDaysSinceCompletion(), calculateAwarenessScore(), or getAwarenessClass(),
 * you MUST update both files to keep them in sync.
 * After changes, verify with: npm test
 */

// Default awareness configuration
export const DEFAULT_AWARENESS_CONFIG = {
  commitment: {
    problemsPerDay: 2
  },
  thresholds: {
    white: 10,
    green: 30,
    yellow: 50,
    red: 70,
    darkRed: 90
  },
  baseRate: 2.0,
  baseSolvedScaling: 0.1,
  tierDifficultyMultipliers: {
    top: {
      Easy: 0,
      Medium: 0.25,
      Hard: 0.4
    },
    advanced: {
      Easy: 1.2,
      Medium: 0.9,
      Hard: 0.7
    },
    intermediate: {
      Easy: 1.5,
      Medium: 1.0,
      Hard: 0.75
    },
    below: {
      Easy: 1.8,
      Medium: 1.3,
      Hard: 1.0
    }
  },
  tierSolvedBonus: {
    top: 0.3,
    advanced: 0.2,
    intermediate: 0.1,
    below: 0
  },
  flashInterval: 500,
  refreshInterval: 86400000,
  refreshOnFocus: true
};

// Current awareness config
let AWARENESS_CONFIG = JSON.parse(JSON.stringify(DEFAULT_AWARENESS_CONFIG));

// Mock global state for testing
let PROBLEM_DATA = {
  file_list: [],
  data: {}
};

/**
 * Set mock problem data for testing
 */
export function setMockProblemData(data) {
  PROBLEM_DATA = data;
}

/**
 * Reset config to defaults
 */
export function resetConfig() {
  AWARENESS_CONFIG = JSON.parse(JSON.stringify(DEFAULT_AWARENESS_CONFIG));
}

/**
 * Set custom config for testing
 */
export function setConfig(config) {
  AWARENESS_CONFIG = config;
}

/**
 * Get current config
 */
export function getConfig() {
  return AWARENESS_CONFIG;
}

/**
 * Get tier name as string (for matrix lookup and solved bonus)
 */
export function getTierName(problem) {
  const timeToSolve = parseFloat(problem.time_to_solve);

  // If no time recorded, use "below" tier
  if (isNaN(timeToSolve) || timeToSolve <= 0) {
    return 'below';
  }

  const topTime = parseFloat(problem.top_time) || Infinity;
  const advancedTime = parseFloat(problem.advanced_time) || Infinity;
  const intermediateTime = parseFloat(problem.intermediate_time) || Infinity;

  if (timeToSolve <= topTime) {
    return 'top';
  } else if (timeToSolve <= advancedTime) {
    return 'advanced';
  } else if (timeToSolve <= intermediateTime) {
    return 'intermediate';
  } else {
    return 'below';
  }
}

/**
 * Get combined tier-difficulty multiplier
 */
export function getTierDifficultyMultiplier(problem) {
  const tier = getTierName(problem);
  const difficulty = problem.difficulty || 'Medium';
  const matrix = AWARENESS_CONFIG.tierDifficultyMultipliers;

  // Fallback to 1.0 if tier or difficulty not found
  if (!matrix[tier]) return 1.0;
  if (matrix[tier][difficulty] === undefined) return 1.0;

  return matrix[tier][difficulty];
}

/**
 * Get total unique solved count across all problem lists
 */
export function getTotalUniqueSolvedCount() {
  const solvedNames = new Set();
  PROBLEM_DATA.file_list.forEach(fileKey => {
    PROBLEM_DATA.data[fileKey].forEach(p => {
      if (p.solved) solvedNames.add(p.name);
    });
  });
  return solvedNames.size;
}

/**
 * Get commitment factor (higher commitment = faster decay)
 */
export function getCommitmentFactor() {
  const commitment = AWARENESS_CONFIG.commitment.problemsPerDay;
  const baseline = 2;
  return commitment / baseline;
}

/**
 * Get solved factor (higher solved count = slower decay)
 */
export function getSolvedFactor(problem) {
  const totalSolved = getTotalUniqueSolvedCount();
  const tier = getTierName(problem);
  const baseScaling = AWARENESS_CONFIG.baseSolvedScaling;
  const tierBonus = AWARENESS_CONFIG.tierSolvedBonus[tier];

  return 1 + (baseScaling + tierBonus) * Math.log2(totalSolved + 1);
}

/**
 * Normalize date to ISO format, returns null if invalid
 */
export function normalizeDateToISO(dateInput) {
  if (!dateInput) return null;

  const date = new Date(dateInput);
  if (isNaN(date.getTime())) return null;

  return date.toISOString();
}

/**
 * Calculate days since completion
 * Returns: { days: number, valid: boolean }
 */
export function getDaysSinceCompletion(solvedDate) {
  if (!solvedDate) return { days: -1, valid: true };

  const now = new Date();
  const date = new Date(solvedDate);

  // Handle invalid dates
  if (isNaN(date.getTime())) {
    console.warn('Invalid date format for solved_date:', solvedDate);
    return { days: -1, valid: false };
  }

  // Handle future dates (clock skew)
  if (date > now) return { days: 0, valid: true };

  const diffMs = now - date;
  const diffDays = diffMs / (1000 * 60 * 60 * 24);
  return { days: diffDays, valid: true };
}

/**
 * Calculate awareness score for a problem
 * Returns: { score: number, invalidDate: boolean }
 */
export function calculateAwarenessScore(problem) {
  // Not solved - return -1 to indicate no awareness styling
  if (!problem.solved) return { score: -1, invalidDate: false };

  const dateResult = getDaysSinceCompletion(problem.solved_date);

  // Invalid date
  if (!dateResult.valid) return { score: -1, invalidDate: true };

  // No valid date (unsolved)
  if (dateResult.days < 0) return { score: -1, invalidDate: false };

  const commitmentFactor = getCommitmentFactor();
  const tierDiffMultiplier = getTierDifficultyMultiplier(problem);
  const solvedFactor = getSolvedFactor(problem);

  const score = dateResult.days * AWARENESS_CONFIG.baseRate * commitmentFactor * tierDiffMultiplier / solvedFactor;

  return { score, invalidDate: false };
}

/**
 * Get CSS class for awareness score
 */
export function getAwarenessClass(score) {
  if (score < 0) return 'unsolved-problem';

  const thresholds = AWARENESS_CONFIG.thresholds;

  if (score < thresholds.white) return 'awareness-white';
  if (score < thresholds.green) return 'awareness-green';
  if (score < thresholds.yellow) return 'awareness-yellow';
  if (score < thresholds.red) return 'awareness-red';
  if (score < thresholds.darkRed) return 'awareness-dark-red';
  return 'awareness-flashing';
}

/**
 * Validate and correct threshold ordering
 * Ensures white < green < yellow < red < darkRed
 */
export function validateThresholdOrdering(thresholds) {
  const corrected = { ...thresholds };
  const keys = ['white', 'green', 'yellow', 'red', 'darkRed'];

  // Ensure strict ordering
  for (let i = 1; i < keys.length; i++) {
    if (corrected[keys[i]] <= corrected[keys[i-1]]) {
      corrected[keys[i]] = corrected[keys[i-1]] + 1;
    }
  }

  // Cap at maximum of 200
  keys.forEach(key => {
    if (corrected[key] > 200) {
      corrected[key] = 200;
    }
  });

  return corrected;
}
