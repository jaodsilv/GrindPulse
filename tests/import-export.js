/**
 * Import/Export JavaScript Functions (Extracted for Testing)
 * These functions are normally embedded in the generated HTML file
 */

/**
 * SYNCHRONIZATION REQUIREMENT:
 * These functions mirror the JavaScript code generated by js_import_export_generator.py.
 * When modifying any of these functions, you MUST update both files to keep them in sync.
 * After changes, verify with: npm test
 */

// Mock PROBLEM_DATA for testing
let PROBLEM_DATA = {
  file_list: [],
  data: {}
};

/**
 * Set mock problem data for testing
 */
export function setMockProblemData(data) {
  PROBLEM_DATA = data;
}

/**
 * Get current mock problem data
 */
export function getMockProblemData() {
  return PROBLEM_DATA;
}

/**
 * Reset mock problem data to empty
 */
export function resetMockProblemData() {
  PROBLEM_DATA = {
    file_list: [],
    data: {}
  };
}

// Export constants
export const MIME_TYPES = {
  tsv: 'text/tab-separated-values;charset=utf-8;',
  csv: 'text/csv;charset=utf-8;',
  json: 'application/json;charset=utf-8;',
  xml: 'application/xml;charset=utf-8;',
  yaml: 'text/yaml;charset=utf-8;'
};

export const FILE_EXTENSIONS = {
  tsv: '.tsv',
  csv: '.csv',
  json: '.json',
  xml: '.xml',
  yaml: '.yaml'
};

// ============================================
// MODE FILTERING
// ============================================

/**
 * Filter problems based on export mode
 * @param {Array} problems - Array of problem objects
 * @param {string} mode - 'full', 'user', or 'problems'
 * @returns {Array} Filtered problem array
 */
export function filterByMode(problems, mode) {
  switch (mode) {
    case 'problems':
      // Static problem data only
      return problems.map(p => ({
        name: p.name,
        difficulty: p.difficulty,
        intermediate_time: p.intermediate_time,
        advanced_time: p.advanced_time,
        top_time: p.top_time,
        pattern: p.pattern
      }));

    case 'user':
      // User progress data only
      return problems.map(p => ({
        name: p.name,
        solved: p.solved,
        time_to_solve: p.time_to_solve,
        comments: p.comments,
        solved_date: p.solved_date
      }));

    case 'full':
    default:
      // All data
      return problems.map(p => ({
        name: p.name,
        difficulty: p.difficulty,
        intermediate_time: p.intermediate_time,
        advanced_time: p.advanced_time,
        top_time: p.top_time,
        pattern: p.pattern,
        solved: p.solved,
        time_to_solve: p.time_to_solve,
        comments: p.comments,
        solved_date: p.solved_date
      }));
  }
}

// ============================================
// HELPER FUNCTIONS
// ============================================

export function getHeadersForMode(mode) {
  switch (mode) {
    case 'problems':
      return ['Problem Name', 'Difficulty', 'Intermediate Time', 'Advanced Time', 'Top Time', 'Pattern'];
    case 'user':
      return ['Problem Name', 'Solved', 'Time to Solve', 'Comments', 'Solved Date'];
    case 'full':
    default:
      return ['Problem Name', 'Difficulty', 'Intermediate Time', 'Advanced Time', 'Top Time', 'Pattern', 'Solved', 'Time to Solve', 'Comments', 'Solved Date'];
  }
}

export function fieldFromHeader(header) {
  const map = {
    'Problem Name': 'name',
    'Difficulty': 'difficulty',
    'Intermediate Time': 'intermediate_time',
    'Intermediate Max time': 'intermediate_time',
    'Advanced Time': 'advanced_time',
    'Advanced Max time': 'advanced_time',
    'Top Time': 'top_time',
    'Top of the crop max time': 'top_time',
    'Pattern': 'pattern',
    'Problem Pattern': 'pattern',
    'Solved': 'solved',
    'Time to Solve': 'time_to_solve',
    'Comments': 'comments',
    'Solved Date': 'solved_date'
  };
  return map[header] || header.toLowerCase().replace(/ /g, '_');
}

export function parseFieldValue(field, value) {
  if (value === null || value === undefined) return '';
  const str = String(value).trim();

  if (field === 'solved') {
    return str.toLowerCase() === 'true' || str === '1';
  }
  return str;
}

export function detectModeFromFields(problem) {
  if (!problem) return 'full';
  const hasUserFields = 'solved' in problem || 'time_to_solve' in problem || 'comments' in problem || 'solved_date' in problem;
  const hasProblemFields = 'difficulty' in problem || 'pattern' in problem || 'intermediate_time' in problem;

  if (hasUserFields && hasProblemFields) return 'full';
  if (hasUserFields) return 'user';
  if (hasProblemFields) return 'problems';
  return 'full';
}

// ============================================
// ESCAPE UTILITIES
// ============================================

// TSV escaping
export function escapeTSVValue(value) {
  if (value === null || value === undefined) return '';
  if (typeof value === 'boolean') return value ? 'true' : 'false';
  return String(value).replace(/\t/g, ' ').replace(/\n/g, ' ').replace(/\r/g, '');
}

// CSV escaping
export function escapeCSVValue(value) {
  if (value === null || value === undefined) return '';
  if (typeof value === 'boolean') return value ? 'true' : 'false';
  const str = String(value);
  if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
    return '"' + str.replace(/"/g, '""') + '"';
  }
  return str;
}

// CSV parsing - handles quoted values
export function parseCSVLines(content) {
  const lines = [];
  let currentLine = [];
  let currentValue = '';
  let inQuotes = false;

  for (let i = 0; i < content.length; i++) {
    const char = content[i];
    const nextChar = content[i + 1];

    if (inQuotes) {
      if (char === '"' && nextChar === '"') {
        currentValue += '"';
        i++;
      } else if (char === '"') {
        inQuotes = false;
      } else {
        currentValue += char;
      }
    } else {
      if (char === '"') {
        inQuotes = true;
      } else if (char === ',') {
        currentLine.push(currentValue);
        currentValue = '';
      } else if (char === '\n' || (char === '\r' && nextChar === '\n')) {
        if (char === '\r') i++;
        currentLine.push(currentValue);
        if (currentLine.length > 0) lines.push(currentLine);
        currentLine = [];
        currentValue = '';
      } else if (char !== '\r') {
        currentValue += char;
      }
    }
  }

  // Handle last value
  currentLine.push(currentValue);
  if (currentLine.length > 0 && currentLine.some(v => v !== '')) {
    lines.push(currentLine);
  }

  return lines;
}

// XML escaping
export function escapeXMLValue(value) {
  if (value === null || value === undefined) return '';
  if (typeof value === 'boolean') return value ? 'true' : 'false';
  return String(value)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

export function escapeXMLAttr(value) {
  if (value === null || value === undefined) return '';
  return String(value)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

// YAML formatting
export function formatYAMLValue(value) {
  if (value === null || value === undefined) return '""';
  if (typeof value === 'boolean') return value ? 'true' : 'false';
  const str = String(value);
  // Quote strings that need it
  if (str.includes(':') || str.includes('#') || str.includes('\n') || str.includes('"') || str.includes("'") || str.trim() !== str) {
    return '"' + str.replace(/\\/g, '\\\\').replace(/"/g, '\\"') + '"';
  }
  return str || '""';
}

export function parseYAMLValue(value) {
  if (!value) return '';
  const trimmed = value.trim();
  // Remove quotes if present
  if ((trimmed.startsWith('"') && trimmed.endsWith('"')) ||
      (trimmed.startsWith("'") && trimmed.endsWith("'"))) {
    return trimmed.slice(1, -1);
  }
  return trimmed;
}

// ============================================
// FORMAT SERIALIZERS
// ============================================

/**
 * Serialize problems to TSV format
 */
export function serializeToTSV(problems, mode) {
  const headers = getHeadersForMode(mode);
  let tsv = headers.join('\t') + '\n';

  problems.forEach(problem => {
    const row = headers.map(h => escapeTSVValue(problem[fieldFromHeader(h)]));
    tsv += row.join('\t') + '\n';
  });

  return tsv;
}

/**
 * Serialize problems to CSV format
 */
export function serializeToCSV(problems, mode) {
  const headers = getHeadersForMode(mode);
  let csv = headers.map(h => escapeCSVValue(h)).join(',') + '\n';

  problems.forEach(problem => {
    const row = headers.map(h => escapeCSVValue(problem[fieldFromHeader(h)]));
    csv += row.join(',') + '\n';
  });

  return csv;
}

/**
 * Serialize problems to JSON format
 */
export function serializeToJSON(problems, mode, fileKey) {
  const exportData = {
    fileKey: fileKey,
    mode: mode,
    exportDate: new Date().toISOString(),
    version: '1.0',
    problems: problems
  };
  return JSON.stringify(exportData, null, 2);
}

/**
 * Serialize problems to XML format
 */
export function serializeToXML(problems, mode, fileKey) {
  let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
  xml += `<export fileKey="${escapeXMLAttr(fileKey)}" mode="${mode}" exportDate="${new Date().toISOString()}" version="1.0">\n`;
  xml += '  <problems>\n';

  problems.forEach(problem => {
    xml += '    <problem>\n';
    for (const [key, value] of Object.entries(problem)) {
      xml += `      <${key}>${escapeXMLValue(value)}</${key}>\n`;
    }
    xml += '    </problem>\n';
  });

  xml += '  </problems>\n';
  xml += '</export>';
  return xml;
}

/**
 * Serialize problems to YAML format
 */
export function serializeToYAML(problems, mode, fileKey) {
  let yaml = `fileKey: ${fileKey}\n`;
  yaml += `mode: ${mode}\n`;
  yaml += `exportDate: "${new Date().toISOString()}"\n`;
  yaml += 'version: "1.0"\n';
  yaml += 'problems:\n';

  problems.forEach(problem => {
    yaml += '  - ';
    const entries = Object.entries(problem);
    entries.forEach(([key, value], idx) => {
      const prefix = idx === 0 ? '' : '    ';
      yaml += `${prefix}${key}: ${formatYAMLValue(value)}\n`;
    });
  });

  return yaml;
}

// ============================================
// FORMAT PARSERS
// ============================================

/**
 * Parse TSV content to problems array
 */
export function parseFromTSV(content) {
  const lines = content.trim().split('\n');
  if (lines.length < 2) return { problems: [], fileKey: null, mode: null };

  const headers = lines[0].split('\t').map(h => h.trim());
  const problems = [];

  for (let i = 1; i < lines.length; i++) {
    const values = lines[i].split('\t');
    if (values.length < headers.length) continue;

    const problem = {};
    headers.forEach((header, idx) => {
      const field = fieldFromHeader(header);
      problem[field] = parseFieldValue(field, values[idx]);
    });
    problems.push(problem);
  }

  return { problems, fileKey: null, mode: detectModeFromFields(problems[0]) };
}

/**
 * Parse CSV content to problems array
 */
export function parseFromCSV(content) {
  const lines = parseCSVLines(content);
  if (lines.length < 2) return { problems: [], fileKey: null, mode: null };

  const headers = lines[0].map(h => h.trim());
  const problems = [];

  for (let i = 1; i < lines.length; i++) {
    const values = lines[i];
    if (values.length < headers.length) continue;

    const problem = {};
    headers.forEach((header, idx) => {
      const field = fieldFromHeader(header);
      problem[field] = parseFieldValue(field, values[idx]);
    });
    problems.push(problem);
  }

  return { problems, fileKey: null, mode: detectModeFromFields(problems[0]) };
}

/**
 * Parse JSON content to problems array
 */
export function parseFromJSON(content) {
  try {
    const data = JSON.parse(content);
    // Handle both array format and object format
    if (Array.isArray(data)) {
      return { problems: data, fileKey: null, mode: detectModeFromFields(data[0]) };
    }
    return {
      problems: data.problems || [],
      fileKey: data.fileKey || null,
      mode: data.mode || detectModeFromFields((data.problems || [])[0])
    };
  } catch (e) {
    console.error('JSON parse error:', e);
    return { problems: [], fileKey: null, mode: null };
  }
}

/**
 * Parse XML content to problems array
 * Note: This requires DOMParser which may not be available in Node.js
 * For testing, use a mock or JSDOM
 */
export function parseFromXML(content, parser = null) {
  try {
    // Use provided parser or global DOMParser
    const domParser = parser || (typeof DOMParser !== 'undefined' ? new DOMParser() : null);
    if (!domParser) {
      console.error('DOMParser not available');
      return { problems: [], fileKey: null, mode: null };
    }

    const doc = domParser.parseFromString(content, 'application/xml');

    const exportEl = doc.querySelector('export');
    const fileKey = exportEl ? exportEl.getAttribute('fileKey') : null;
    const mode = exportEl ? exportEl.getAttribute('mode') : null;

    const problemElements = doc.querySelectorAll('problem');
    const problems = [];

    problemElements.forEach(el => {
      const problem = {};
      for (const child of el.children) {
        problem[child.tagName] = parseFieldValue(child.tagName, child.textContent);
      }
      problems.push(problem);
    });

    return { problems, fileKey, mode: mode || detectModeFromFields(problems[0]) };
  } catch (e) {
    console.error('XML parse error:', e);
    return { problems: [], fileKey: null, mode: null };
  }
}

/**
 * Parse YAML content to problems array
 */
export function parseFromYAML(content) {
  try {
    const lines = content.split('\n');
    let fileKey = null;
    let mode = null;
    const problems = [];
    let currentProblem = null;
    let inProblems = false;

    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;

      if (trimmed.startsWith('fileKey:')) {
        fileKey = parseYAMLValue(trimmed.substring(8).trim());
      } else if (trimmed.startsWith('mode:')) {
        mode = parseYAMLValue(trimmed.substring(5).trim());
      } else if (trimmed === 'problems:') {
        inProblems = true;
      } else if (inProblems) {
        if (trimmed.startsWith('- ')) {
          if (currentProblem) problems.push(currentProblem);
          currentProblem = {};
          const rest = trimmed.substring(2);
          if (rest.includes(':')) {
            const [key, ...valueParts] = rest.split(':');
            const value = valueParts.join(':').trim();
            currentProblem[key.trim()] = parseFieldValue(key.trim(), parseYAMLValue(value));
          }
        } else if (currentProblem && trimmed.includes(':')) {
          const [key, ...valueParts] = trimmed.split(':');
          const value = valueParts.join(':').trim();
          currentProblem[key.trim()] = parseFieldValue(key.trim(), parseYAMLValue(value));
        }
      }
    }

    if (currentProblem) problems.push(currentProblem);

    return { problems, fileKey, mode: mode || detectModeFromFields(problems[0]) };
  } catch (e) {
    console.error('YAML parse error:', e);
    return { problems: [], fileKey: null, mode: null };
  }
}

// ============================================
// FORMAT DETECTION
// ============================================

/**
 * Detect file format from filename or content
 */
export function detectFormat(filename, content) {
  const ext = filename.split('.').pop().toLowerCase();
  if (['tsv', 'csv', 'json', 'xml', 'yaml', 'yml'].includes(ext)) {
    return ext === 'yml' ? 'yaml' : ext;
  }

  // Content-based detection
  const trimmed = content.trim();
  if (trimmed.startsWith('{') || trimmed.startsWith('[')) return 'json';
  if (trimmed.startsWith('<?xml') || trimmed.startsWith('<export')) return 'xml';
  if (trimmed.includes('\t') && !trimmed.includes(',')) return 'tsv';
  if (trimmed.startsWith('fileKey:') || trimmed.startsWith('problems:')) return 'yaml';
  return 'csv';
}

// ============================================
// CONFLICT DETECTION
// ============================================

/**
 * Detect conflicts between existing and imported data
 */
export function detectConflicts(fileKey, importedData, mode) {
  const existingData = PROBLEM_DATA.data[fileKey];
  if (!existingData) return [];

  const conflicts = [];

  importedData.forEach((imported, importIdx) => {
    const existingIdx = existingData.findIndex(e => e.name === imported.name);

    if (existingIdx !== -1) {
      const existing = existingData[existingIdx];
      let hasConflict = false;

      if (mode === 'user' || mode === 'full') {
        // Check user data conflicts
        if ((imported.solved !== undefined && existing.solved !== imported.solved) ||
            (imported.time_to_solve !== undefined && existing.time_to_solve !== imported.time_to_solve) ||
            (imported.comments !== undefined && existing.comments !== imported.comments) ||
            (imported.solved_date !== undefined && existing.solved_date !== imported.solved_date)) {
          hasConflict = true;
        }
      }

      if (mode === 'problems' || mode === 'full') {
        // Check problem definition conflicts
        if ((imported.difficulty !== undefined && existing.difficulty !== imported.difficulty) ||
            (imported.pattern !== undefined && existing.pattern !== imported.pattern) ||
            (imported.intermediate_time !== undefined && existing.intermediate_time !== imported.intermediate_time) ||
            (imported.advanced_time !== undefined && existing.advanced_time !== imported.advanced_time) ||
            (imported.top_time !== undefined && existing.top_time !== imported.top_time)) {
          hasConflict = true;
        }
      }

      if (hasConflict) {
        conflicts.push({
          name: imported.name,
          existingIdx: existingIdx,
          importIdx: importIdx,
          existing: existing,
          imported: imported
        });
      }
    }
  });

  return conflicts;
}
